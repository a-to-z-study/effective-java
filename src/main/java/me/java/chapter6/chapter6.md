## Item 34: int 상수 대신 열거 타입을 사용하라

열거 타입은 일정 개수의 상수 값을 정의한 다음, 그 외의 값은 허용하지 않는 타입이다.  
자바에서 열거 타입을 지원하기 전에는 정수 상수를 한 묶음 선언해서 사용하곤 했는데,  
타입 안전을 보장할 방법이 없으며, 표현력도 좋지 않으므로 지양하는 것이 좋다.

예를 들어 다음과 같이 오렌지와 사과를 정수 상수로 정의하고 동등 연산자로 비교해도 컴파일러는 아무런 경고 메시지를 출력하지 않는 문제가 있다.
```java
public static final int APPLE_FUJI = 0;
public static final int APPLE_PIPPIN = 1;

public static final int ORANGE_NAVEL = 0;
public static final int ORANGE_TEMPLE = 1;

boolean isSame = APPLE_FUJI == ORANGE_NAVEL;  // true
```

그러므로 자바에서 제공하는 열거 패턴의 단점을 말끔히 씻어주는 동시에 여러 장점을 안겨주는 열거 타입이라는 대안을 사용하자.
```java
public enum Apple { FUJI, PIPPIN, ... }
public enum Orange { NAVEL, TEMPLE, ... }
```
겉보기에는 C, C++, C# 같은 다른 언어의 열거 타입과 비슷하지만, 자바의 열거 타입은 완전한 형태의 클래스라서 다른 언어의 열거 타입보다 훨씬 강력하다.  
열거 타입 자체는 클래스이며, 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개한다.  
열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 final이다.  
따라서 클라이언트가 인스턴스를 직접 생성하거나 확장할 수 없으니 **열거 타입 선언으로 만들어진 인스턴스들은 딱 하나씩만 존재함**이 보장된다.

열거 타입의 장점
1. 컴파일 타입 안전성을 제공한다.
2. 각자의 이름 공간이 있어서 이름이 같은 상수도 공존할 수 있다.
3. toString 메서드는 출력하기에 적합한 문자열을 내어준다.
4. 임의의 메서드나 필드를 추가할 수 있고, 임의의 인터페이스를 구현하게 할 수도 있다.
5. Comparable과 Serializable을 구현했으며, 직렬화 형태도 웬만큼 변형을 가해도 문제없이 동작하게끔 구현해놨다.

<br/>

## Item 36: 비트 필드 대신 EnumSet을 사용하라

java.util 패키지의 EnumSet 클래스는 열거 타입 상수의 값으로 구성된 집합을 효과적으로 표현해준다.  
Set 인터페이스를 완벽히 구현하며, 타입 안전하고, 다른 어떤 Set 구현체와도 함께 사용할 수 있다.  
하지만 EnumSet의 내부는 비트 벡터로 구현되었다.  
원소가 총 64개 이하라면, 즉 대부분의 경우에 EnumSet 전체를 long 변수 하나로 표현하여 비트 필드에 비견되는 성능을 보여준다.  
removeAll과 retainAll 같은 대량 작업은 비트를 효율적으로 처리할 수 있는 산술 연산을 써서 구현했다.  

<br/>

## Item 40: `@Override` 애너테이션을 일관되게 사용하라

`@Override`는 메서드 선언에만 달 수 있으며, 이 애너테이션이 달렸다는 것은 상위 타입의 메서드를 재정의했음을 뜻한다.  
이 애너테이션을 일관되게 사용하면 여러 가지 악명 높은 버그들을 예방해준다.  
상위 메서드를 재정의하려고 했으나 실수로 다중 정의할 수 있는 문제를 `@Override` 애너테이션을 붙이면 컴파일 단계에서 오류를 발견할 수 있다.

<br/>

## Item 41: 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

아무 메서드도 담지 않고 있고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시해주는 인터페이스를 마커 인터페이스라 한다.  
예를 들어 Serializable 인터페이스가 있다.  

마커 애너테이션이 등장하면서 마커 인터페이스는 구식이 되었다는 이야기를 들어보았을 것이다. 하지만 사실이 아니다.  
마커 인터페이스는 두 가지 측면에서 마커 애너테이션보다 낫다.
1. 마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 쓸 수 있으나, 마커 에너테이션은 그렇지 않다.  
마커 인터페이스는 어엿한 타입이기 때문에 마커 애너테이션을 사용했다면 런타임에야 발견될 오류를 컴파일타임에 발견할 수 있다.
2. 적용 대상을 더 정밀하게 지정할 수 있다.  

> 반대로 마커 애너테이션이 마커 인터페이스보다 나은 점으로는 거대한 애너테이션 시스템의 지원을 받는다는 점을 들 수 있다.  
> 따라서 애너테이션을 적극 활용하는 프레임워크에서는 마커 애너테이션을 쓰는 쪽이 일관성을 지키는 데 유리할 것이다.
