## Item 26: 로 타입은 사용하지 말라

클래스와 인터페이스 선언에 대해 타입 매개변수(type-parameter)가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라 한다.  
예를 들어 List 인터페이스는 원소의 타입을 나타내는 타입 매개변수 E를 받는다.  
그래서 이 인터페이스의 완전한 이름은 List<E>지만, 짧게 그냥 List라고도 자주 쓴다.  
그리고 제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입이라 한다.

제네릭 타입을 하나 정의하면 그에 딸린 로 타입도 함께 정의된다.  
로 타입이란, 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.  
예를 들어 List<E>의 로 타입은 List다.  
로 타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환되도록 하기 위한 궁여지책이라 할 수 있다.  

이 책 전반에서 줄기차게 이야기하듯, 오류는 가능한 한 발생 즉시, 이상적으로는 컴파일할 때 발견하는 것이 좋다.  
로 타입을 쓰는 걸 언어 차원에서 막아 놓지는 않았지만, 로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.

```
비한정적 와일드카드 타입이란, 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경쓰고 싶지 않을 때 ?를 사용하는 것을 말한다.  
예를 들어 제네릭 타입인 Set<E>의 비한정적 와일드카드 타입은 Set<?>이다.
이것은 어떤 타입이라도 담을 수 있는 가장 범용적인 매개변수화 Set 타입이다.  
이때 Set<?>에는 null 외에는 어떤 원소도 넣을 수 없다.
```

한 마디로 정리하면, 로 타입은 런타임에 예외가 발생할 수 있으니 사용하면 안된다.  
로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.

<br/>

## Item 28: 배열보다는 리스트를 사용하라

배열과 제네릭 타입의 차이 두 가지
1. 배열은 공변(함께 변한다는 뜻)이지만, 제네릭은 불공변이다.  
Sub가 Super의 하위 타입이라면 배열 `Sub[]`는 배열 `Super[]`의 하위 타입이 된다.  
그러나 `List<Sub>`는 `List<Super>`의 하위 타입도 아니고 상위 타입도 아니다.
2. 배열은 실체화된다. 즉, 배열은 런타임에도 자신이 담기로한 원소의 타입을 인지하고 확인한다.  
그래서 Long 배열에 String을 넣으려 하면 ArrayStoreException이 발생한다.  
반면, 제네릭은 타입 정보가 런타임에는 소거된다. 즉, 원소 타입을 컴파일타임에만 검사하며 런타임에는 알 수 없다는 뜻이다.  
소거는 제네릭이 지원되기 전의 레거시 코드와 제네릭 타입을 함께 사용할 수 있게 해주는 메커니즘이다.

이러한 주요 차이로 인해 배열과 제네릭은 잘 어우러지지 못한다.  

<br/>

## Item 29: 이왕이면 제네릭 타입으로 만들라

Object 기반 스택을 제네릭으로 변경해보자.

예제 코드
- [Object 기반 스택](ObjectStack.java)
- [배열을 사용한 코드를 제네릭으로 만드는 방법 1](GenericStack1.java)
- [배열을 사용한 코드를 제네릭으로 만드는 방법 2](GenericStack2.java)

제네릭 배열 생성을 제거하는 두 방법 모두 나름의 지지를 얻고 있다.  
첫 번째 방법은 가독성이 더 좋다. 배열의 타입을 E[]로 선언하여 오직 E 타입 인스턴스만 받음을 확실히 어필한다.  
코드도 더 짧다. 보통의 제네릭 클래스라면 코드 이곳저곳에서 배열을 자주 사용할 것이다.  

첫 번째 방식에서는 형변환을 배열 생성 시 단 한 번만 해주면 되지만, 두 번째 방식에서는 배열에서 원소를 읽을 때마다 해줘야 한다.  
따라서 현업에서는 첫 번째 방식을 더 선호하며 자주 사용한다.  

하지만 배열의 런타임 타입이 컴파일타임 타입과 달라 힙 오염을 일으킨다. (Item 32)  
힙 오염이 맘에 걸리는 프로그래머는 두 번째 방식을 고수하기도 한다.
