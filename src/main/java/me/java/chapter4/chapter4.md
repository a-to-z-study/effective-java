## Item 17: 변경 가능성을 최소화하라

---

<br>

**불변 클래스로 만드는 방법**

- 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다. (final class)
- 모든 필드를 final로 선언한다.
- 모든 필드를 private으로 선언하여 필드가 참조하는 가변 객체를 직접 수정하지 못하게 한다.
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다. (필드를 그대로 반환하지 않고 방어적 복사)

<br>

**불변 객체의 장점**

- 불변 객체는 근본적으로 스레드 안전하여 동기화할 필요가 없다.
    - 공유, 재활용 이점
- 가변 객체에 비해 GC 성능상의 이점이 있을 수 있다.
    - 객체 생성에 대한 비용은 과대평가되고 있으며, 이는 불변 객체를 이용한 효율로 충분히 상쇄할 수 있다.
    - GC는 새롭게 생성된 객체는 금방 죽는다는 Weak Generational Hypothesis 가설에 맞춰 설계
    - 불변 객체를 새로 생성한다 해도 GC는 생명주기가 짧은 객체 처리에 대한 부담이 적다.
    - 불변 객체를 이용하면 GC의 스캔 빈도와 범위가 줄게 되어 GC의 성능에 도움이 된다
    - 가변 객체는 일반적으로 상태를 변경하는 형식으로 사용해서 불변 객체보다 생명 주기가 길고 지속적으로 GC의 스캔 범위에 포함되어 불변 객체보다 성능상 이점이 적다.

<br>

BigInteger, BigDecimal의 메서드는 `final`이 아니라 `Override`가 가능하다.
신뢰할 수 없는 클라이언트로부터 BigDecimal의 인스턴스를 인수로 받는다면 주의해야 한다.

```java
public static BigInteger safeInstance(BigInteger val) {
	return val.getClass() == BigInteger.class ? val : new BigInteger(val.toByteArray());
}
```

<br>

## Item 18: 상속보다는 컴포지션을 이용하라

---

상속의 단점

- 캡슐화를 깨뜨린다.
    - 상위 클래스는 릴리스마다 내부 구현이 달라질 수 있으며, 그 여파로 하위 클래스가 오동작할 수 있다.

상속은 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에서만 쓰여야 한다.
- `is-a` 관계일 때만 상속
    - 이 원칙을 위반한 클래스 (`Stack`은 `Vector`를 확장)
- 컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴

<br>

## Item 20: 추상 클래스보다는 인터페이스를 우선하라

---

<br>

**자바가 제공하는 다중 구현 메커니즘**
- 인터페이스
- 추상 클래스

추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다.
자바는 단일 상속만 지원(다이아몬드 문졔)하니, 추상 클래스 방식은 새로운 타입을 정의하는 데 커다란 제약을 안게 되는 셈이다.

반면 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.

인터페이스 default method 다중 상속 문제

```java
public class Test implements TestA, TestB{
	// TestA, TestB 의 default method가 같은 경우
	@Override
	public void testDefault() {
		TestA.super.testDefault();
	}
}
```

<br>

## Item 22: 인터페이스는 타입을 정의하는 용도로만 사용하라

---

인터페이스를 상수를 뜻하는 `static final` 필드로만 가득 찬 인터페이스로 만드는 것은 안티 패턴

필요하다면 상수 유틸리티 클래스를 만들자